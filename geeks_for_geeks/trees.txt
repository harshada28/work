Reverse alternate levels of a perfect binary tree
Given a Perfect Binary Tree, reverse the alternate level nodes of the binary tree.

  
Given tree: 
               a
            /     \
           b       c
         /  \     /  \
        d    e    f    g
       / \  / \  / \  / \
       h  i j  k l  m  n  o 

Modified tree:
  	       a
            /     \
           c       b
         /  \     /  \
        d    e    f    g
       / \  / \  / \  / \
      o  n m  l k  j  i  h 
_____________________________________________________________________________________________________________________________________
Transform a BST to greater sum tree
Given a BST, transform it into greater sum tree where each node contains sum of all nodes greater than that node.
_____________________________________________________________________________________________________________________________________
Print a Binary Tree in Vertical Order | Set 2 (Hashmap based Method)
Given a binary tree, print it vertically. The following example illustrates vertical order traversal.

           1
        /    \
       2      3
      / \    / \
     4   5  6   7
             \   \
              8   9 
               
			  
The output of print this tree vertically will be:
4
2
1 5 6
3 8
7
9
_____________________________________________________________________________________________________________________________________
Print Right View of a Binary Tree
Given a Binary Tree, print Right view of it. Right view of a Binary Tree is set of nodes visible when tree is 
visited from Right side.

Right view of following tree is 1 3 7 8

          1
       /     \
     2        3
   /   \     /  \
  4     5   6    7
                  \
                   8
_____________________________________________________________________________________________________________________________________
Construct a tree from Inorder and Level order traversals
Given inorder and level-order traversals of a Binary Tree, construct the Binary Tree. Following is an example to 
illustrate the problem.


Input: Two arrays that represent Inorder
       and level order traversals of a 
       Binary Tree
in[]    = {4, 8, 10, 12, 14, 20, 22};
level[] = {20, 8, 22, 4, 12, 10, 14};

Output: Construct the tree represented 
        by the two arrays.
        For the above two arrays, the 
        constructed tree is shown in 
        the diagram on right side
_____________________________________________________________________________________________________________________________________
Print all nodes at distance k from a given node
Given a binary tree, a target node in the binary tree, and an integer value k, print all
 the nodes that are at distance k from the given target node. No parent pointers are available.

Consider the tree shown in diagram

Input: target = pointer to node with data 8. 
       root = pointer to node with data 20.
       k = 2.
Output : 10 14 22

If target is 14 and k is 3, then output 
should be "4 20"
_____________________________________________________________________________________________________________________________________
Print a Binary Tree in Vertical Order | Set 1
Given a binary tree, print it vertically. The following example illustrates vertical order traversal.

           1
        /    \
       2      3
      / \    / \
     4   5  6   7
             \   \
              8   9 
               
			  
The output of print this tree vertically will be:
4
2
1 5 6
3 8
7
9_____________________________________________________________________________________________________________________________________
Interval Tree
Consider a situation where we have a set of intervals and we need following operations to be implemented efficiently. 
1) Add an interval
2) Remove an interval
3) Given an interval x, find if x overlaps with any of the existing intervals.

Interval Tree: The idea is to augment a self-balancing Binary Search Tree (BST) like Red Black Tree, AVL Tree, 
etc to maintain set of intervals so that all operations can be done in O(Logn) time.

Every node of Interval Tree stores following information.
a) i: An interval which is represented as a pair [low, high]
b) max: Maximum high value in subtree rooted with this node.

The low value of an interval is used as key to maintain order in BST. The insert and delete operations
 are same as insert and delete in self-balancing BST used
_____________________________________________________________________________________________________________________________________
Check if a given Binary Tree is height balanced like a Red-Black Tree
In a Red-Black Tree, the maximum height of a node is at most twice the minimum height 
(The four Red-Black tree properties make sure this is always followed). Given a Binary Search Tree,
 we need to check for following property.
For every node, length of the longest leaf to node path has not more than twice the nodes 
on shortest path from node to leaf.

    12                                        40
      \                                     /    \ 
       14                                 10      100    
         \                                        /  \
          16                                     60   150    
 Cannot be a Red-Black Tree              It can be Red-Black Tree
 with any color assignment
 Max height of 12 is 1
 Min height of 12 is 3


          10
        /   \
      5     100
           /   \
          50   150
         /
        40 
 It can also be Red-Black Tree
Expected time complexity is O(n). The tree should be traversed at-most once in the solution.
_____________________________________________________________________________________________________________________________________

Print all nodes that are at distance k from a leaf node
Given a Binary Tree and a positive integer k, print all nodes that are distance k from a leaf node.

Here the meaning of distance is different from previous post. Here k distance from a leaf means k levels
 higher than a leaf node. For example if k is more than height of Binary Tree, then nothing should be printed.
 Expected time complexity is O(n) where n is the number nodes in the given Binary Tree.
_____________________________________________________________________________________________________________________________________
Find distance between two given keys of a Binary Tree
Find the distance between two keys in a binary tree, no parent pointers are given. Distance between 
two nodes is the minimum number of edges to be traversed to reach one node from other.
_____________________________________________________________________________________________________________________________________
Lowest Common Ancestor in a Binary Tree | Set 1
Given a binary tree (not a binary search tree) and two values say n1 and n2, write a program to find the least common ancestor.
_____________________________________________________________________________________________________________________________________
Print all nodes that don’t have sibling
Given a Binary Tree, print all nodes that don’t have a sibling (a sibling is a node that has same parent. 
In a Binary Tree, there can be at most one sibling). Root should not be printed as root cannot have a sibling.
_____________________________________________________________________________________________________________________________________
Convert a given Binary Tree to Doubly Linked List | Set 3
Given a Binary Tree (BT), convert it to a Doubly Linked List(DLL) In-Place. The left and right pointers
 in nodes are to be used as previous and next pointers respectively in converted DLL.
 The order of nodes in DLL must be same as Inorder of the given Binary Tree. The first node of Inorder
 traversal (left most node in BT) must be head node of the DLL.
_____________________________________________________________________________________________________________________________________
Sum of all the numbers that are formed from root to leaf paths
Given a binary tree, where every node value is a Digit from 1-9 .Find the sum of all the 
numbers which are formed from root to leaf paths.

For example consider the following Binary Tree.

                                          6
                                      /      \
                                    3          5
                                  /   \          \
                                 2     5          4  
                                      /   \
                                     7     4
  There are 4 leaves, hence 4 root to leaf paths:
   Path                    Number
  6->3->2                   632
  6->3->5->7               6357
  6->3->5->4               6354
  6->5>4                    654   
Answer = 632 + 6357 + 6354 + 654 = 13997 
_____________________________________________________________________________________________________________________________________
Find next right node of a given key
Given a Binary tree and a key in the binary tree, find the node right to the given key.
 If there is no node on right side, then return NULL. Expected time complexity is O(n) 
where n is the number of nodes in the given binary tree.

For example, consider the following Binary Tree. Output for 2 is 6, output for 4 is 5. 
Output for 10, 6 and 5 is NULL.

                  10
               /      \
	      2         6
           /   \         \ 
	 8      4          5
_____________________________________________________________________________________________________________________________________
Deepest left leaf node in a binary tree
Given a Binary Tree, find the deepest leaf node that is left child of its parent. For example, 
consider the following tree. The deepest left leaf node is the node with value 9.

       1
     /   \
    2     3
  /      /  \  
 4      5    6
        \     \
         7     8
        /       \
       9         10
_____________________________________________________________________________________________________________________________________
Extract Leaves of a Binary Tree in a Doubly Linked List
Given a Binary Tree, extract all leaves of it in a Doubly Linked List (DLL). Note that the DLL need 
to be created in-place. Assume that the node structure of DLL and Binary Tree is same,
 only the meaning of left and right pointers are different. In DLL, left means previous pointer and right means next pointer.

Let the following be input binary tree
        1
     /     \
    2       3
   / \       \
  4   5       6
 / \         / \
7   8       9   10


Output:
Doubly Linked List
7<->8<->5<->9<->10

Modified Tree:
        1
     /     \
    2       3
   /         \
  4           6
_____________________________________________________________________________________________________________________________________
Remove all nodes which don’t lie in any path with sum>= k
Given a binary tree, a complete path is defined as a path from root to a leaf. The sum of all nodes on that path is 
defined as the sum of that path. Given a number K, you have to remove (prune the tree) all nodes which don’t 
lie in any path with sum>=k.

Note: A node can be part of multiple paths. So we have to delete it only in case when all paths from it have sum less than K.

Consider the following Binary Tree
          1 
      /      \
     2        3
   /   \     /  \
  4     5   6    7
 / \    /       /
8   9  12      10
   / \           \
  13  14         11
      / 
     15 

For input k = 20, the tree should be changed to following
(Nodes with values 6 and 8 are deleted)
          1 
      /      \
     2        3
   /   \        \
  4     5        7
   \    /       /
    9  12      10
   / \           \
  13  14         11
      / 
     15 

For input k = 45, the tree should be changed to following.
      1 
    / 
   2   
  / 
 4  
  \   
   9    
    \   
     14 
     /
    15 

_____________________________________________________________________________________________________________________________________
Add all greater values to every node in a given BST
Given a Binary Search Tree (BST), modify it so that all greater values in the given BST are added to every node. 

              50
           /      \
         30        70
        /   \      /  \
      20    40    60   80 

The above tree should be modified to following 

              260
           /      \
         330        150
        /   \       /  \
      350   300    210   80
_____________________________________________________________________________________________________________________________________
Print Left View of a Binary Tree
Given a Binary Tree, print left view of it. Left view of a Binary Tree is set of nodes visible when tree 
is visited from left side. Left view of following tree is 12, 10, 25.

          12
       /     \
     10       30
            /    \
          25      40 
The left view contains all nodes that are first nodes in their levels.
_____________________________________________________________________________________________________________________________________
Check if all leaves are at same level
Given a Binary Tree, check if all leaves are at same level or not.
_____________________________________________________________________________________________________________________________________
Find depth of the deepest odd level leaf node
Write a C code to get the depth of the deepest odd level leaf node in a binary tree. 
Consider that level starts with 1. Depth of a leaf node is number of nodes on the path from root to leaf (including both leaf and root).
_____________________________________________________________________________________________________________________________________
Print Postorder traversal from given Inorder and Preorder traversals
_____________________________________________________________________________________________________________________________________
Difference between sums of odd level and even level nodes of a Binary Tree
Given a a Binary Tree, find the difference between the sum of nodes at odd level and 
the sum of nodes at even level. Consider root as level 1, left and right children of root as level 2 and so on.

For example, in the following tree, sum of nodes at odd level is (5 + 1 + 4 + 8) which is 18. 
And sum of nodes at even level is (2 + 6 + 3 + 7 + 9) which is 27. The output for following tree should be 18 – 27 which is -9.

      5
    /   \
   2     6
 /  \     \  
1    4     8
    /     / \ 
   3     7   9  
_____________________________________________________________________________________________________________________________________
Print ancestors of a given binary tree node without recursion
Given a Binary Tree and a key, write a function that prints all the ancestors of the key in the given binary tree.

For example, consider the following Binary Tree

            1
        /       \
       2         3
     /   \     /   \
    4     5    6    7 
   /       \       /
  8         9     10  
Following are different input keys and their ancestors in the above tree

Input Key    List of Ancestors 
-------------------------
 1            
 2            1
 3            1
 4            2 1
 5            2 1
 6            3 1
 7            3 1
 8            4 2 1
 9            5 2 1
10            7 3 1
_____________________________________________________________________________________________________________________________________
Convert a given Binary Tree to Doubly Linked List | Set 2
Given a Binary Tree (BT), convert it to a Doubly Linked List(DLL). 
The left and right pointers in nodes are to be used as previous and next pointers respectively in converted DLL. 
The order of nodes in DLL must be same as Inorder of the given Binary Tree. The first node of Inorder traversal
 (left most node in BT) must be head node of the DLL.
_____________________________________________________________________________________________________________________________________
Check for Identical BSTs without building the trees
Given two arrays which represent a sequence of keys. Imagine we make a Binary Search Tree (BST) from each array. 
We need to tell whether two BSTs will be identical or not without actually constructing the tree.
_____________________________________________________________________________________________________________________________________
Custom Tree Problem
You are given a set of links, e.g.

a ---> b
b ---> c
b ---> d
a ---> e 
Print the tree that would form when each pair of these links that has the same character as start 
and end point is joined together. You have to maintain fidelity w.r.t. the height of nodes, i.e. 
nodes at height n from root should be printed at same row or column. For set of links given above, tree printed should be –

-->a
   |-->b
   |   |-->c
   |   |-->d
   |-->e
Note that these links need not form a single tree; they could form, ahem, a forest. Consider the following links

a ---> b
a ---> g
b ---> c
c ---> d
d ---> e
c ---> f
z ---> y
y ---> x
x ---> w
The output would be following forest.

-->a
   |-->b
   |   |-->c
   |   |   |-->d
   |   |   |   |-->e
   |   |   |-->f
   |-->g

-->z
   |-->y
   |   |-->x
   |   |   |-->w
You can assume that given links can form a tree or forest of trees only, and there are no duplicates among links.
_____________________________________________________________________________________________________________________________________
Iterative Method to find Height of Binary Tree
_____________________________________________________________________________________________________________________________________
Find all possible interpretations of an array of digits
Consider a coding system for alphabets to integers where ‘a’ is represented as 1, ‘b’ as 2, .. ‘z’ as 26. Given an array of digits (1 to 9) as input, write a function that prints all valid interpretations of input array.

Examples

Input: {1, 1}
Output: ("aa", 'k") 
[2 interpretations: aa(1, 1), k(11)]

Input: {1, 2, 1}
Output: ("aba", "au", "la") 
[3 interpretations: aba(1,2,1), au(1,21), la(12,1)]

Input: {9, 1, 8}
Output: {"iah", "ir"} 
[2 interpretations: iah(9,1,8), ir(9,18)]
Please note we cannot change order of array. That means {1,2,1} cannot become {2,1,1}
On first look it looks like a problem of permutation/combination. But on closer look you will figure 
out that this is an interesting tree problem.
The idea here is string can take at-most two paths:
1. Proces single digit
2. Process two digits
That means we can use binary tree here. Processing with single digit will be left child and two digits will be right child. 
If value two digits is greater than 26 then our right child will be null as we don’t have alphabet for greater than 26.

Let’s understand with an example .Array a = {1,2,1}. Below diagram shows that how our tree grows.

                           “” {1,2,1}            Codes used in tree
                       /             \               "a" --> 1
                      /               \              "b" --> 2 
                  "a"{2,1}            "l"{1}         "l" --> 12
                 /        \          /     \
                /          \        /       \
            "ab"{1}        "au"    "la"      null
             /    \
            /      \
         "aba"      null
Braces {} contain array still pending for processing. Note that with every level, our array size decreases. 
If you will see carefully, it is not hard to find that tree height is always n (array size)
How to print all strings (interpretations)? Output strings are leaf node of tree. i.e for {1,2,1}, output is {aba au la}.
We can conclude that there are mainly two steps to print all interpretations of given integer array.
_____________________________________________________________________________________________________________________________________
Tree Isomorphism Problem
Write a function to detect if two trees are isomorphic. Two trees are called isomorphic if one of them can be obtained 
from other by a series of flips, i.e. by swapping left and right children of a number of nodes. 
Any number of nodes at any level can have their children swapped. Two empty trees are isomorphic.

For example, following two trees are isomorphic with following sub-trees flipped: 2 and 3, NULL and 6, 7 and 8.
_____________________________________________________________________________________________________________________________________
Longest prefix matching – A Trie based solution in Java
Given a dictionary of words and an input string, find the longest prefix of the string which is also a word in dictionary.

Examples:

Let the dictionary contains the following words:
{are, area, base, cat, cater, children, basement}

Below are some input/output examples:
--------------------------------------
Input String            Output
--------------------------------------
caterer                 cater
basemexy                base
child                   < Empty >
_____________________________________________________________________________________________________________________________________
Convert a given Binary Tree to Doubly Linked List | Set 1
Given a Binary Tree (Bt), convert it to a Doubly Linked List(DLL). The left and right pointers in nodes are to be used as 
previous and next pointers respectively in converted DLL. The order of nodes in DLL must be same as Inorder of the given Binary Tree. 
The first node of Inorder traversal (left most node in BT) must be head node of the DLL.
_____________________________________________________________________________________________________________________________________
Remove BST keys outside the given range
Given a Binary Search Tree (BST) and a range [min, max], remove all keys which are outside the given range. 
The modified tree should also be BST. For example, consider the following BST and range [-10, 13]. 
_____________________________________________________________________________________________________________________________________
Construct Complete Binary Tree from its Linked List Representation
Given Linked List Representation of Complete Binary Tree, construct the Binary tree. A complete binary tree can be 
represented in an array in the following approach.

If root node is stored at index i, its left, and right children are stored at indices 2*i+1, 2*i+2 respectively.
Suppose tree is represented by a linked list in same way, how do we convert this into normal linked representation of binary 
tree where every node has data, left and right pointers? In the linked list representation, we cannot directly access the children of 
the current node unless we traverse the list.
_____________________________________________________________________________________________________________________________________
Reverse Level Order Traversal
We have discussed level order traversal of a post in previous post. The idea is to print last level first, 
then second last level, and so on. Like Level order traversal, every level is printed from left to right.
_____________________________________________________________________________________________________________________________________
Find a pair with given sum in a Balanced BST
Given a Balanced Binary Search Tree and a target sum, write a function that returns true if there is a pair with sum 
equals to target sum, otherwise return false. Expected time complexity is O(n) and only O(Logn) extra space can be used. 
Any modification to Binary Search Tree is not allowed. Note that height of a Balanced BST is always O(Logn).
_____________________________________________________________________________________________________________________________________
Find if there is a triplet in a Balanced BST that adds to zero
Given a Balanced Binary Search Tree (BST), write a function isTripletPresent() that returns true if there is a triplet in given BST 
with sum equals to 0, otherwise returns false. Expected time complexity is O(n^2) and only O(Logn) extra space can be used.
 You can modify given Binary Search Tree. Note that height of a Balanced BST is always O(Logn)
For example, isTripletPresent() should return true for following BST because there is a triplet with sum 0, the triplet is {-13, 6, 7}.
_____________________________________________________________________________________________________________________________________

Iterative Postorder Traversal | Set 2 (Using One Stack)
We have discussed a simple iterative postorder traversal using two stacks in the previous post. In this post, 
an approach with only one stack is discussed.

The idea is to move down to leftmost node using left pointer. While moving down, push root and root’s right child to stack. 
Once we reach leftmost node, print it if it doesn’t have a right child. If it has a right child, then change root so that the
 right child is processed before.
_____________________________________________________________________________________________________________________________________
Iterative Postorder Traversal | Set 1 (Using Two Stacks)
We have discussed iterative inorder and iterative preorder traversals. In this post, iterative postorder traversal is discussed which is
 more complex than the other two traversals (due to its nature of non-tail recursion, there is an extra statement after 
the final recursive call to itself).
 The postorder traversal can easily be done using two stacks though. The idea is to push reverse postorder traversal to a stack.
 Once we have reverse postorder traversal in a stack, we can just pop all items one by one from the stack and print them, this order 
of printing will be in postorder because of LIFO property of stacks. Now the question is, how to get reverse post order elements in a 
stack – the other stack is used for this purpose. For example, in the following tree, we need to get 1, 3, 7, 6, 2, 5, 4 in a stack. 
If take a closer look at this sequence, 
we can observe that this sequence is very similar to preorder traversal. The only difference is right child is visited before left child 
and therefore sequence is “root right left” instead of “root left right”. So we can do something like iterative preorder traversal 
with following differences.
a) Instead of printing an item, we push it to a stack.
b) We push left subtree before right subtree.
_____________________________________________________________________________________________________________________________________
Dynamic Programming | Set 26 (Largest Independent Set Problem)
Given a Binary Tree, find size of the Largest Independent Set(LIS) in it. A subset of all tree nodes is an independent 
set if there is no edge between any two nodes of the subset.
For example, consider the following binary tree. The largest independent set(LIS) is {10, 40, 60, 70, 80} and size of the LIS is 5.
_____________________________________________________________________________________________________________________________________
Segment Tree | Set 2 (Range Minimum Query)
We have introduced segment tree with a simple example in the previous post. In this post, Range Minimum Query 
problem is discussed as another example where Segment Tree can be used. Following is problem statement.

We have an array arr[0 . . . n-1]. We should be able to efficiently find the minimum value from index qs (query start) to qe 
(query end) where 0 <= qs <= qe <= n-1. The array is static (elements are not deleted and inserted during the series of queries).
_____________________________________________________________________________________________________________________________________
Segment Tree | Set 1 (Sum of given range)
Let us consider the following problem to understand Segment Trees.

We have an array arr[0 . . . n-1]. We should be able to
1 Find the sum of elements from index l to r where 0 <= l <= r <= n-1
2 Change value of a specified element of the array arr[i] = x where 0 <= i <= n-1.
_____________________________________________________________________________________________________________________________________
Ternary Search Tree
A ternary search tree is a special trie data structure where the child nodes of a standard trie are ordered as a binary search tree.
_____________________________________________________________________________________________________________________________________
Linked complete binary tree & its creation
A complete binary tree is a binary tree where each level ‘l’ except the last has 2^l nodes and the nodes at 
the last level are all left aligned. Complete binary trees are mainly used in heap based data structures.
The nodes in the complete binary tree are inserted from left to right in one level at a time. If a level is full, 
the node is inserted in a new level.
_____________________________________________________________________________________________________________________________________
Morris traversal for Preorder
Using Morris Traversal, we can traverse the tree without using stack and recursion. The algorithm for Preorder is 
almost similar to Morris traversal for Inorder.

1...If left child is null, print the current node data. Move to right child.
….Else, Make the right child of the inorder predecessor point to the current node. Two cases arise:
………a) The right child of the inorder predecessor already points to the current node. Set right child to NULL.
 Move to right child of current node.
………b) The right child is NULL. Set it to current node. Print current node’s data and move to left child of current node.
2...Iterate until current node is not NULL.
_____________________________________________________________________________________________________________________________________
Convert a BST to a Binary Tree such that sum of all greater keys is added to every key
Given a Binary Search Tree (BST), convert it to a Binary Tree such that every key of the original BST is changed to 
key plus sum of all greater keys in BST.
_____________________________________________________________________________________________________________________________________
Iterative Preorder Traversal
Given a Binary Tree, write an iterative function to print Preorder traversal of the given binary tree.
_____________________________________________________________________________________________________________________________________
Floor and Ceil from a BST
There are numerous applications we need to find floor (ceil) value of a key in a binary search tree or sorted array. 
For example, consider designing memory management system in which free nodes are arranged in BST. Find best fit for the input request.

Ceil Value Node: Node with smallest data larger than or equal to key value.
_____________________________________________________________________________________________________________________________________
Construct BST from given preorder traversal | Set 2
Given preorder traversal of a binary search tree, construct the BST.
_____________________________________________________________________________________________________________________________________
Construct BST from given preorder traversal | Set 1
Given preorder traversal of a binary search tree, construct the BST.

For example, if the given traversal is {10, 5, 1, 7, 40, 50}, then the output should be root of following tree.
_____________________________________________________________________________________________________________________________________
Construct Full Binary Tree from given preorder and postorder traversals
Given two arrays that represent preorder and postorder traversals of a full binary tree, construct the binary tree.
_____________________________________________________________________________________________________________________________________
Two nodes of a BST are swapped, correct the BST
Two of the nodes of a Binary Search Tree (BST) are swapped. Fix (or correct) the BST.
_____________________________________________________________________________________________________________________________________
Boundary Traversal of binary tree
Given a binary tree, print boundary nodes of the binary tree Anti-Clockwise starting from the root. For example, 
boundary traversal of the following tree is “20 8 4 10 14 25 22″
_____________________________________________________________________________________________________________________________________
Check whether a given Binary Tree is Complete or not
_____________________________________________________________________________________________________________________________________
Check if each internal node of a BST has exactly one child
Given Preorder traversal of a BST, check if each non-leaf node has only one child. Assume that the BST contains unique entries.
_____________________________________________________________________________________________________________________________________
Construct a special tree from given preorder traversal
Given an array ‘pre[]‘ that represents Preorder traversal of a spacial binary tree where every node has either 0 or 2 children.
 One more array ‘preLN[]‘ is given which has only two possible values ‘L’ and ‘N’. The value ‘L’ in ‘preLN[]‘ indicates that 
the corresponding node in Binary Tree is a leaf node and value ‘N’ indicates that the corresponding node is non-leaf node. 
Write a function to construct the tree from the given two arrays.
_____________________________________________________________________________________________________________________________________
Construct Special Binary Tree from given Inorder traversal
Given Inorder Traversal of a Special Binary Tree in which key of every node is greater than keys 
in left and right children, construct the Binary Tree and return root.
_____________________________________________________________________________________________________________________________________
Binary Tree to Binary Search Tree Conversion
Given a Binary Tree, convert it to a Binary Search Tree. The conversion must be done in such a way that
 keeps the original structure of Binary Tree.
_____________________________________________________________________________________________________________________________________
Merge two BSTs with limited extra space
Given two Binary Search Trees(BST), print the elements of both BSTs in sorted form. 
The expected time complexity is O(m+n) where m is the number of nodes in first tree and n is the number of nodes in second tree.
 Maximum allowed auxiliary space is O(height of the first tree + height of the second tree).
_____________________________________________________________________________________________________________________________________
Find the maximum sum leaf to root path in a Binary Tree
Given a Binary Tree, find the maximum sum path from a leaf to root. For example, in the following tree, there are three leaf 
to root paths 8->-2->10, -4->-2->10 and 7->10. The sums of these three paths are 16, 4 and 17 respectively. 
The maximum of them is 17 and the path for maximum is 7->10.
_____________________________________________________________________________________________________________________________________
_____________________________________________________________________________________________________________________________________
Page 6
_____________________________________________________________________________________________________________________________________

Merge Two Balanced Binary Search Trees
You are given two balanced binary search trees e.g., AVL or Red Black Tree. Write a function that merges the two given
 balanced BSTs into a balanced binary search tree. Let there be m elements in first tree and n elements in the other tree. 
Your merge function should take O(m+n) time.
_____________________________________________________________________________________________________________________________________
Vertical Sum in a given Binary Tree
Given a Binary Tree, find vertical sum of the nodes that are in same vertical line. Print all sums through different vertical lines.
_____________________________________________________________________________________________________________________________________
Find the largest BST subtree in a given Binary Tree
Given a Binary Tree, write a function that returns the size of the largest subtree which is also a Binary Search Tree (BST). 
If the complete Binary Tree is BST, then return the size of whole tree.
_____________________________________________________________________________________________________________________________________
Convert a given tree to its Sum Tree
Given a Binary Tree where each node has positive and negative values.
 Convert this to a tree where each node contains the sum of the left and right sub trees in the original tree. 
The values of leaf nodes are changed to 0.
_____________________________________________________________________________________________________________________________________
Populate Inorder Successor for all nodes
Given a Binary Tree where each node has following structure, write a function to populate next pointer for all nodes. 
The next pointer for every node should be set to point to inorder successor.

struct node
{
  int data;
  struct node* left;
  struct node* right;
  struct node* next;
}
Initially, all next pointers have NULL values. Your function should fill these next pointers so that they point to inorder successor.
_____________________________________________________________________________________________________________________________________
Sorted Array to Balanced BST
Given a sorted array. Write a function that creates a Balanced Binary Search Tree using array elements.
_____________________________________________________________________________________________________________________________________
Connect nodes at same level using constant extra space
Write a function to connect all the adjacent nodes at the same level in a binary tree. Structure of the given 
Binary Tree node is like following.

struct node {
  int data;
  struct node* left;
  struct node* right;
  struct node* nextRight;
}
Initially, all the nextRight pointers point to garbage values. Your function should set these pointers to point
 next right for each node. You can use only constant extra space.
_____________________________________________________________________________________________________________________________________
Connect nodes at same level
Write a function to connect all the adjacent nodes at the same level in a binary tree. Structure of the given 
Binary Tree node is like following.

struct node{
  int data;
  struct node* left;
  struct node* right;
  struct node* nextRight;  
}
Initially, all the nextRight pointers point to garbage values. Your function should set these pointers to point next right for each node.
_____________________________________________________________________________________________________________________________________
Check if a binary tree is subtree of another binary tree
Given two binary trees, check if the first tree is subtree of the second one. A subtree of a tree T is a 
tree S consisting of a node in T and all of its descendants in T. The subtree corresponding to the root node 
is the entire tree; the subtree corresponding to any other node is called a proper subtree.
_____________________________________________________________________________________________________________________________________
Decision Trees – Fake (Counterfeit) Coin Puzzle (12 Coin Puzzle)
_____________________________________________________________________________________________________________________________________
_____________________________________________________________________________________________________________________________________
Page 7
_____________________________________________________________________________________________________________________________________
Check if a given Binary Tree is SumTree
Write a function that returns true if the given Binary Tree is SumTree else false. A SumTree is a Binary Tree 
where the value of a node is equal to sum of the nodes present in its left subtree and right subtree. 
An empty tree is SumTree and sum of an empty tree can be considered as 0. A leaf node is also considered as SumTre
_____________________________________________________________________________________________________________________________________
Tournament Tree (Winner Tree) and Binary Heap
Given a team of N players. How many minimum games are required to find second best player?

We can use adversary arguments based on tournament tree (Binary Heap).
_____________________________________________________________________________________________________________________________________
Print BST keys in the given range
Given two values k1 and k2 (where k1 < k2) and a root pointer to a Binary Search Tree. 
Print all the keys of tree in range k1 to k2. i.e. print all x such that k1<=x<=k2 and x is a key of given BST. Print all the keys in increasing order.

For example, if k1 = 10 and k2 = 22, then your function should print 12, 20 and 22.
_____________________________________________________________________________________________________________________________________
Print Ancestors of a given node in Binary Tree
Given a Binary Tree and a key, write a function that prints all the ancestors of the key in the given binary tree.

For example, if the given tree is following Binary Tree and key is 7, then your function should print 4, 2 and 1
_____________________________________________________________________________________________________________________________________
Get Level of a node in a Binary Tree
Given a Binary Tree and a key, write a function that returns level of the key.

For example, consider the following tree. If the input key is 3, then your function should return 1. 
If the input key is 4, then your function should return 3. And for key which is not present in key, then your function should return 0.
_____________________________________________________________________________________________________________________________________
Find k-th smallest element in BST (Order Statistics in BST)
Given root of binary search tree and K as input, find K-th smallest element in BST.

For example, in the following BST, if k = 3, then output should be 10, and if k = 5, then output should be 14.
_____________________________________________________________________________________________________________________________________
Inorder Successor in Binary Search Tree
In Binary Tree, Inorder successor of a node is the next node in Inorder traversal of the Binary Tree. Inorder Successor is NULL for the 
last node in Inoorder traversal.
In Binary Search Tree, Inorder Successor of an input node can also be defined as the node with the smallest key greater than the key of input node. 
So, it is sometimes important to find next node in sorted order.
_____________________________________________________________________________________________________________________________________
Sorted order printing of a given array that represents a BST
Given an array that stores a complete Binary Search Tree, write a function that efficiently prints the given array in ascending order.

For example, given an array [4, 2, 5, 1, 3], the function should print 1, 2, 3, 4, 5
_____________________________________________________________________________________________________________________________________
Print nodes at k distance from root
Given a root of a tree, and an integer k. Print all the nodes which are at k distance from root.
_____________________________________________________________________________________________________________________________________
Foldable Binary Trees
Question: Given a binary tree, find out if the tree can be folded or not.

A tree can be folded if left and right subtrees of the tree are structure wise mirror image of each other. An empty tree is considered as foldable.
_____________________________________________________________________________________________________________________________________
Maximum width of a binary tree
Given a binary tree, write a function to get the maximum width of the given tree. Width of a tree is maximum of widths of all levels.
_____________________________________________________________________________________________________________________________________
Double Tree
Write a program that converts a given tree to its Double tree. To create Double tree of the given tree, create a new duplicate for each node, and insert the duplicate as the left child of the original node.

So the tree…

    2
   / \
  1   3
is changed to…

       2
      / \
     2   3
    /   /
   1   3
  /
 1
And the tree

            1
          /   \
        2      3
      /  \
    4     5
is changed to

               1
             /   \
           1      3
          /      /
        2       3
      /  \
     2    5
    /    /
   4   5
  /   
 4
_____________________________________________________________________________________________________________________________________
_____________________________________________________________________________________________________________________________________
Page 8
_____________________________________________________________________________________________________________________________________
Given a binary tree, print all root-to-leaf paths
_____________________________________________________________________________________________________________________________________
Construct Tree from given Inorder and Preorder traversals
_____________________________________________________________________________________________________________________________________
Root to leaf path sum equal to a given number
Given a binary tree and a number, return true if the tree has a root-to-leaf path such that adding up all the 
values along the path equals the given number. Return false if no such path can be found.
_____________________________________________________________________________________________________________________________________
Inorder Tree Traversal without recursion and without stack!_____________________________________________________________________________________________________________________________________
Inorder Tree Traversal without Recursion
_____________________________________________________________________________________________________________________________________
How to determine if a binary tree is height-balanced?
A tree where no leaf is much farther away from the root than any other leaf. Different balancing 
schemes allow different definitions of “much farther” and different amounts of work to keep them balanced.
_____________________________________________________________________________________________________________________________________
Diameter of a Binary Tree
The diameter of a tree (sometimes called the width) is the number of nodes on the longest path between two leaves in the tree. 
The diagram below shows two trees each with diameter nine, the leaves that form the ends of a longest path are shaded
 (note that there is more than one path in each tree of length nine, but no path longer than nine nodes).
_____________________________________________________________________________________________________________________________________
Convert an arbitrary Binary Tree to a tree that holds Children Sum Property
_____________________________________________________________________________________________________________________________________
Check for Children Sum Property in a Binary Tree.
Given a binary tree, write a function that returns true if the tree satisfies below property.
_____________________________________________________________________________________________________________________________________
Level order traversal in spiral form _____________________________________________________________________________________________________________________________________
A program to check if a binary tree is BST or not
_____________________________________________________________________________________________________________________________________
Program to count leaf nodes in a binary tree
_____________________________________________________________________________________________________________________________________
Level Order Tree Traversal
_____________________________________________________________________________________________________________________________________
Find the node with minimum value in a Binary Search Tree
_____________________________________________________________________________________________________________________________________
Page 9
_____________________________________________________________________________________________________________________________________
The Great Tree-List Recursion Problem.
_____________________________________________________________________________________________________________________________________
Lowest Common Ancestor in a Binary Search Tree.
_____________________________________________________________________________________________________________________________________
Given a binary tree, print out all of its root-to-leaf paths one per line.
_____________________________________________________________________________________________________________________________________
Write an Efficient C Function to Convert a Binary Tree into its Mirror Tree
_____________________________________________________________________________________________________________________________________
Write a C program to Delete a Tree.
_____________________________________________________________________________________________________________________________________
Write a C Program to Find the Maximum Depth or Height of a Tree
_____________________________________________________________________________________________________________________________________
Write C Code to Determine if Two Trees are Identical
_____________________________________________________________________________________________________________________________________

Write a C program to Calculate Size of a tree Size of a tree is the number of elements present in the tree.
_____________________________________________________________________________________________________________________________________
Tree Traversals
_____________________________________________________________________________________________________________________________________



